---
sidebar_position: 1
---

- **this** 는 자바스크립트에서의 this는 어디에서든 사용 가능.
- 상황에 따라 this가 바라보는 대상이 달라진다.

- 실행 컨텍스트는 함수를 호출할 때 생성
- 실행 컨텍스트가 생성될 때(함수를 호출할 때) 함께 결정
- 함수 호출 방식에 따라 값이 상이

### 3-1-1 전역 공간에서의 this

- 전역 공간에서 this는 전역 객체 (전역 컨텍스트를 생성하는 주체가 전역 객체이기 때문)
- 전역 객체

  - 자바스크립트 런타임 환경에 따라 다른 이름과 정보를 가지고 있음
  - 브라우저 환경: window
  - Node.js 환경: global

    ```javascript
    console.log(this === window); // true
    console.log(this === global); // true
    ```

- 자바스크립트의 특이한 성질

  - 전역변수를 선언하면 자바스크립트 엔진은 이를 전연객체의 프로퍼티로도 할당
  - (정확하게는) _전역변수를 선언하면 자바스크립트 엔진은 이를 전역객체의 프로퍼티로 할당_
  - 변수이면서도 객체의 프로퍼티

    ```jsx
    var name = 'youjin';
    console.log(name); // case1: youjin
    console.log(window.name); // case2: youjin
    console.log(this.name); // case3: youjin
    ```

  - window.name과 this.name이 'youjin' 을 출력하는 이유 (case2, 3)

    - 자바스크립트의 모든 변수는 특정 객체의 프로퍼티로서 동작하기 때문
    - var 연산자를 이용해 변수를 선언해도 자바스크립트 엔진은 어떤 특정 객체의 프로퍼티로 인식
    - 특정 객체 = 실행 컨텍스트의 LE
    - 실행 컨텍스트는 변수를 수집해서 LE의 프로퍼티로 저장
    - 어떤 변수를 호출하면 LE를 조회해서 일치하는 프로퍼티가 있으면, 그 값을 반환
    - 전역 컨텍스트는 LE 전역객체를 그대로 참조 (정확하게는 GlobalEnv가 전역 객체를 참조)

  - name를 직접 호출할 때도 'youjin'을 출력하는 이유 (case1)

    - 변수 name에 접근하려할 때 스코프 체인에서 name을 찾고,
      가장 마지막에 도달하는 전역 스코프 LE(전역객체)에서 해당 프로퍼트 name을 발견하여 그 값을 반환하기 때문
      (window.이 생략되어 있다고 생각해도 됨)

    [참고] let 연산자를 사용할 때

    ```jsx
    let name = 'youjin';
    console.log(name); // youjin
    console.log(window.name); // undefined
    console.log(this.name); // undefined

    💡 let 을 사용했을 때 undefined가 출력되는 이유는 호이스팅 때문!
    ```

- window 프로퍼티에 직접 할당하면?

  - (대부분은) 결과적으로 var로 선언한 것과 똑같이 동작

    ```jsx
    window.name = 'youjin';
    console.log(window.name); // youjin
    ```

  ```
  - 대부분이라는 건 예외가 존재
  - 예외
    - 삭제 명령

  ```

### 3-1-2 메서드로서 호출할 때 그 메서드 내부에서의 this

### 3-1-3 함수로서 호출할 때 그 함수 내부에서의 this

### 3-1-4 콜백 함수 호출 시 그 함수 내부에서의 this

### 3-1-5 생성자 함수 내부에서의 this
